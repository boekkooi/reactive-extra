// Generated by CoffeeScript 1.6.2
(function() {
  var HandlebarsEach, SparkListObserve, findParentOfType, makeRange;

  HandlebarsEach = Handlebars._default_helpers.each;

  Handlebars._default_helpers.each = function(arg, options) {
    var elseFunc, itemFunc;

    if (!(arg && arg instanceof ReactiveList)) {
      return HandlebarsEach.call(this, arg, options);
    }
    itemFunc = function(item) {
      return Spark.labelBranch((item && item._id) || Spark.UNIQUE_LABEL, function() {
        return Spark.setDataContext(item, Spark.isolate(_.bind(options.fn, null, item)));
      });
    };
    elseFunc = function() {
      if (options.inverse) {
        return Spark.isolate(options.inverse);
      } else {
        return '';
      }
    };
    return SparkListObserve(arg, itemFunc, elseFunc);
  };

  Spark._ANNOTATION_LIST_OBSERVE = "list_observe";

  Spark._ANNOTATION_LIST_OBSERVE_ITEM = "list_observe_item";

  SparkListObserve = function(observable, itemFunc, elseFunc) {
    var callbacks, cleanup, handle, html, itemArr, later, maybeAnnotate, notifyParentsRendered, observerCallbacks, outerRange, renderer, stopped;

    elseFunc = elseFunc || function() {
      return '';
    };
    callbacks = {};
    observerCallbacks = {};
    _.each(["addedAt", "changedAt", "removedAt", "movedTo"], function(name) {
      return observerCallbacks[name] = function() {
        return callbacks[name].apply(null, arguments);
      };
    });
    itemArr = [];
    _.extend(callbacks, {
      addedAt: function(val, idx) {
        return itemArr[idx] = {
          liveRange: null,
          value: val
        };
      }
    });
    handle = observable.observe(observerCallbacks);
    renderer = Spark._currentRenderer.get();
    maybeAnnotate = renderer ? _.bind(renderer.annotate, renderer) : function(html) {
      return html;
    };
    html = '';
    outerRange = null;
    if (itemArr.length === 0) {
      html = elseFunc();
    } else {
      _.each(itemArr, function(elt) {
        return html += maybeAnnotate(itemFunc(elt.value), Spark._ANNOTATION_LIST_OBSERVE_ITEM, function(range) {
          elt.liveRange = range;
        });
      });
    }
    stopped = false;
    cleanup = function() {
      handle.stop();
      return stopped = true;
    };
    html = maybeAnnotate(html, Spark._ANNOTATION_LIST_OBSERVE, function(range) {
      if (!range) {
        cleanup();
        return;
      }
      outerRange = range;
      outerRange.finalize = cleanup;
    });
    if (!renderer) {
      cleanup();
      return html;
    }
    notifyParentsRendered = function() {
      var walk;

      walk = outerRange;
      while ((walk = findParentOfType(Spark._ANNOTATION_LANDMARK, walk))) {
        walk.rendered.call(walk.landmark);
      }
    };
    later = function(func) {
      Deps.afterFlush(function() {
        if (!stopped) {
          func();
        }
      });
    };
    _.extend(callbacks, {
      addedAt: function(val, idx) {
        return later(function() {
          var frag, range;

          frag = Spark.render(_.bind(itemFunc, null, val));
          DomUtils.wrapFragmentForContainer(frag, outerRange.containerNode());
          range = makeRange(Spark._ANNOTATION_LIST_ITEM, frag);
          if (itemArr.length === 0) {
            Spark.finalize(outerRange.replaceContents(frag));
          } else {
            itemArr[idx - 1].liveRange.insertAfter(frag);
          }
          return itemArr[idx] = {
            liveRange: range,
            value: val
          };
        });
      },
      removedAt: function(val, idx) {
        return later(function() {
          var frag;

          if (itemArr.length === 1) {
            frag = Spark.render(elseFunc);
            DomUtils.wrapFragmentForContainer(frag, outerRange.containerNode());
            Spark.finalize(outerRange.replaceContents(frag));
          } else {
            Spark.finalize(itemArr[idx].liveRange.extract());
          }
          itemArr.splice(idx, 1);
          return notifyParentsRendered();
        });
      },
      movedTo: function(val, fromIdx, toIdx) {
        return later(function() {
          var elt, frag;

          elt = (itemArr.splice(fromIdx, 1))[0];
          frag = elt.liveRange.extract();
          if (toIdx in itemArr) {
            itemArr[toIdx].liveRange.insertBefore(frag);
          } else {
            itemArr[toIdx - 1].liveRange.insertAfter(frag);
          }
          itemArr.splice(toIdx, 0, elt);
          return notifyParentsRendered();
        });
      },
      changedAt: function(val, idx) {
        return later(function() {
          var elt;

          elt = itemArr[idx];
          if (!elt) {
            throw new Error("Unknown item at index: " + idx);
          }
          elt.value = val;
          return Spark.renderToRange(elt.liveRange, _.bind(itemFunc, null, elt.value));
        });
      }
    });
    return html;
  };

  findParentOfType = function(type, range) {
    while (true) {
      range = range.findParent();
      if (!(range && range.type !== type)) {
        break;
      }
    }
    return range;
  };

  makeRange = function(type, start, end, inner) {
    var range;

    range = new LiveRange(Spark._TAG, start, end, inner);
    range.type = type;
    return range;
  };

}).call(this);
